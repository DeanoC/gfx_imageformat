//Auto generated by formatgen on Aug 16 2019
#pragma once

#include "tinyimageformat_base.h"

#if __cplusplus
#define TIF_CONSTEXPR constexpr
#else
#define TIF_CONSTEXPR
#endif
#ifndef  TinyImageFormat_HAVE_UINTXX_T
#include <stdint.h> 	// for uint32_t and int64_t
#endif
#ifndef  TinyImageFormat_HAVE_BOOL
#include <stdbool.h>	// for bool
#endif
#ifndef  TinyImageFormat_HAVE_POWF
#include <math.h>	// for powf
#endif
#ifndef  TinyImageFormat_ASSERT
#include <assert.h>
#define  TinyImageFormat_ASSERT assert
#endif



// from D3DX_DXGIFormatConvert.inl
inline uint8_t TinyImageFormat_Float2SRGB(float v) {
	if (v < 0.0031308f) {
		v *= 12.92f;
	} else {
		v = 1.055f * powf(v, 1.0f / 2.4f) - 0.055f;
	}
	return (uint8_t)v;
}

inline uint16_t TinyImageFormat_FloatToBFloatAsUint(float v) {
	union {
		struct {
			uint16_t u;
			uint16_t x;
		};
		float f;
	} o;

	o.f = v;
	o.x = 0;

	return o.u;
}

TIF_CONSTEXPR inline bool TinyImageFormat_CanPutLogicalPixelsF(TinyImageFormat const fmt) {
	switch(fmt) {
		case TinyImageFormat_R1_UNORM: return true;
		case TinyImageFormat_R2_UNORM: return true;
		case TinyImageFormat_R4_UNORM: return true;
		case TinyImageFormat_R4G4_UNORM: return true;
		case TinyImageFormat_G4R4_UNORM: return true;
		case TinyImageFormat_A8_UNORM: return true;
		case TinyImageFormat_R8_UNORM: return true;
		case TinyImageFormat_R8_SNORM: return true;
		case TinyImageFormat_R8_UINT: return true;
		case TinyImageFormat_R8_SINT: return true;
		case TinyImageFormat_R8_SRGB: return true;
		case TinyImageFormat_B2G3R3_UNORM: return true;
		case TinyImageFormat_R4G4B4A4_UNORM: return true;
		case TinyImageFormat_R4G4B4X4_UNORM: return true;
		case TinyImageFormat_B4G4R4A4_UNORM: return true;
		case TinyImageFormat_B4G4R4X4_UNORM: return true;
		case TinyImageFormat_A4R4G4B4_UNORM: return true;
		case TinyImageFormat_X4R4G4B4_UNORM: return true;
		case TinyImageFormat_A4B4G4R4_UNORM: return true;
		case TinyImageFormat_X4B4G4R4_UNORM: return true;
		case TinyImageFormat_R5G6B5_UNORM: return true;
		case TinyImageFormat_B5G6R5_UNORM: return true;
		case TinyImageFormat_R5G5B5A1_UNORM: return true;
		case TinyImageFormat_B5G5R5A1_UNORM: return true;
		case TinyImageFormat_A1B5G5R5_UNORM: return true;
		case TinyImageFormat_A1R5G5B5_UNORM: return true;
		case TinyImageFormat_R5G5B5X1_UNORM: return true;
		case TinyImageFormat_B5G5R5X1_UNORM: return true;
		case TinyImageFormat_X1R5G5B5_UNORM: return true;
		case TinyImageFormat_X1B5G5R5_UNORM: return true;
		case TinyImageFormat_B2G3R3A8_UNORM: return true;
		case TinyImageFormat_R8G8_UNORM: return true;
		case TinyImageFormat_R8G8_SNORM: return true;
		case TinyImageFormat_G8R8_UNORM: return true;
		case TinyImageFormat_G8R8_SNORM: return true;
		case TinyImageFormat_R8G8_UINT: return true;
		case TinyImageFormat_R8G8_SINT: return true;
		case TinyImageFormat_R8G8_SRGB: return true;
		case TinyImageFormat_R16_UNORM: return true;
		case TinyImageFormat_R16_SNORM: return true;
		case TinyImageFormat_R16_UINT: return true;
		case TinyImageFormat_R16_SINT: return true;
		case TinyImageFormat_R16_SFLOAT: return true;
		case TinyImageFormat_R16_SBFLOAT: return true;
		case TinyImageFormat_R8G8B8_UNORM: return true;
		case TinyImageFormat_R8G8B8_SNORM: return true;
		case TinyImageFormat_R8G8B8_UINT: return true;
		case TinyImageFormat_R8G8B8_SINT: return true;
		case TinyImageFormat_R8G8B8_SRGB: return true;
		case TinyImageFormat_B8G8R8_UNORM: return true;
		case TinyImageFormat_B8G8R8_SNORM: return true;
		case TinyImageFormat_B8G8R8_UINT: return true;
		case TinyImageFormat_B8G8R8_SINT: return true;
		case TinyImageFormat_B8G8R8_SRGB: return true;
		case TinyImageFormat_R8G8B8A8_UNORM: return true;
		case TinyImageFormat_R8G8B8A8_SNORM: return true;
		case TinyImageFormat_R8G8B8A8_UINT: return true;
		case TinyImageFormat_R8G8B8A8_SINT: return true;
		case TinyImageFormat_R8G8B8A8_SRGB: return true;
		case TinyImageFormat_B8G8R8A8_UNORM: return true;
		case TinyImageFormat_B8G8R8A8_SNORM: return true;
		case TinyImageFormat_B8G8R8A8_UINT: return true;
		case TinyImageFormat_B8G8R8A8_SINT: return true;
		case TinyImageFormat_B8G8R8A8_SRGB: return true;
		case TinyImageFormat_R8G8B8X8_UNORM: return true;
		case TinyImageFormat_B8G8R8X8_UNORM: return true;
		case TinyImageFormat_R16G16_UNORM: return true;
		case TinyImageFormat_G16R16_UNORM: return true;
		case TinyImageFormat_R16G16_SNORM: return true;
		case TinyImageFormat_G16R16_SNORM: return true;
		case TinyImageFormat_R16G16_UINT: return true;
		case TinyImageFormat_R16G16_SINT: return true;
		case TinyImageFormat_R16G16_SFLOAT: return true;
		case TinyImageFormat_R16G16_SBFLOAT: return true;
		case TinyImageFormat_R32_UINT: return true;
		case TinyImageFormat_R32_SINT: return true;
		case TinyImageFormat_R32_SFLOAT: return true;
		case TinyImageFormat_A2R10G10B10_UNORM: return true;
		case TinyImageFormat_A2R10G10B10_UINT: return true;
		case TinyImageFormat_A2B10G10R10_UNORM: return true;
		case TinyImageFormat_A2B10G10R10_UINT: return true;
		case TinyImageFormat_R10G10B10A2_UNORM: return true;
		case TinyImageFormat_B10G10R10A2_UNORM: return true;
		case TinyImageFormat_B10G10R10A2_UINT: return true;
		case TinyImageFormat_B10G11R11_UFLOAT: return true;
		case TinyImageFormat_R16G16B16_UNORM: return true;
		case TinyImageFormat_R16G16B16_SNORM: return true;
		case TinyImageFormat_R16G16B16_UINT: return true;
		case TinyImageFormat_R16G16B16_SINT: return true;
		case TinyImageFormat_R16G16B16_SFLOAT: return true;
		case TinyImageFormat_R16G16B16_SBFLOAT: return true;
		case TinyImageFormat_R16G16B16A16_UNORM: return true;
		case TinyImageFormat_R16G16B16A16_SNORM: return true;
		case TinyImageFormat_R16G16B16A16_UINT: return true;
		case TinyImageFormat_R16G16B16A16_SINT: return true;
		case TinyImageFormat_R16G16B16A16_SFLOAT: return true;
		case TinyImageFormat_R16G16B16A16_SBFLOAT: return true;
		case TinyImageFormat_R32G32_UINT: return true;
		case TinyImageFormat_R32G32_SINT: return true;
		case TinyImageFormat_R32G32_SFLOAT: return true;
		case TinyImageFormat_R32G32B32_UINT: return true;
		case TinyImageFormat_R32G32B32_SINT: return true;
		case TinyImageFormat_R32G32B32_SFLOAT: return true;
		case TinyImageFormat_R32G32B32A32_UINT: return true;
		case TinyImageFormat_R32G32B32A32_SINT: return true;
		case TinyImageFormat_R32G32B32A32_SFLOAT: return true;
		default: return false;
		}
	}

TIF_CONSTEXPR inline bool TinyImageFormat_PutLogicalPixelsF(TinyImageFormat const fmt, float const *in, uint32_t const width, TinyImageFormat_PutOutput * out) {
	switch(fmt) {
		case TinyImageFormat_R1_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint8_t)(in[0] * 1.00f) & 0x1) << 0;
				*op0 |= ((uint8_t)(in[4] * 1.00f) & 0x1) << 1;
				*op0 |= ((uint8_t)(in[8] * 1.00f) & 0x1) << 2;
				*op0 |= ((uint8_t)(in[12] * 1.00f) & 0x1) << 3;
				*op0 |= ((uint8_t)(in[16] * 1.00f) & 0x1) << 4;
				*op0 |= ((uint8_t)(in[20] * 1.00f) & 0x1) << 5;
				*op0 |= ((uint8_t)(in[24] * 1.00f) & 0x1) << 6;
				*op0 |= ((uint8_t)(in[28] * 1.00f) & 0x1) << 7;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=32;
			}
			return true;
		case TinyImageFormat_R2_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint8_t)(in[0] * 3.00f) & 0x3) << 0;
				*op0 |= ((uint8_t)(in[4] * 3.00f) & 0x3) << 2;
				*op0 |= ((uint8_t)(in[8] * 3.00f) & 0x3) << 4;
				*op0 |= ((uint8_t)(in[12] * 3.00f) & 0x3) << 6;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=16;
			}
			return true;
		case TinyImageFormat_R4_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint8_t)(in[0] * 15.00f) & 0xf) << 0;
				*op0 |= ((uint8_t)(in[4] * 15.00f) & 0xf) << 4;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=8;
			}
			return true;
		case TinyImageFormat_R4G4_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint8_t)(in[0] * 15.00f) & 0xf) << 0;
				*op0 |= ((uint8_t)(in[1] * 15.00f) & 0xf) << 4;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_G4R4_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint8_t)(in[1] * 15.00f) & 0xf) << 0;
				*op0 |= ((uint8_t)(in[0] * 15.00f) & 0xf) << 4;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_A8_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint8_t)(in[3] * 255.00f) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint8_t)(in[0] * 255.00f) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8_SNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint8_t)(((in[0] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint8_t)in[0]) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint8_t)(in[0] + 128.00f)) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8_SRGB:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint8_t)TinyImageFormat_Float2SRGB((float)in[0])) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B2G3R3_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint8_t)(in[2] * 3.00f) & 0x3) << 0;
				*op0 |= ((uint8_t)(in[1] * 7.00f) & 0x7) << 2;
				*op0 |= ((uint8_t)(in[0] * 7.00f) & 0x7) << 5;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R4G4B4A4_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[0] * 15.00f) & 0xf) << 0;
				*op0 |= ((uint16_t)(in[1] * 15.00f) & 0xf) << 4;
				*op0 |= ((uint16_t)(in[2] * 15.00f) & 0xf) << 8;
				*op0 |= ((uint16_t)(in[3] * 15.00f) & 0xf) << 12;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R4G4B4X4_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[0] * 15.00f) & 0xf) << 0;
				*op0 |= ((uint16_t)(in[1] * 15.00f) & 0xf) << 4;
				*op0 |= ((uint16_t)(in[2] * 15.00f) & 0xf) << 8;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B4G4R4A4_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[2] * 15.00f) & 0xf) << 0;
				*op0 |= ((uint16_t)(in[1] * 15.00f) & 0xf) << 4;
				*op0 |= ((uint16_t)(in[0] * 15.00f) & 0xf) << 8;
				*op0 |= ((uint16_t)(in[3] * 15.00f) & 0xf) << 12;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B4G4R4X4_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[2] * 15.00f) & 0xf) << 0;
				*op0 |= ((uint16_t)(in[1] * 15.00f) & 0xf) << 4;
				*op0 |= ((uint16_t)(in[0] * 15.00f) & 0xf) << 8;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_A4R4G4B4_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[3] * 15.00f) & 0xf) << 0;
				*op0 |= ((uint16_t)(in[0] * 15.00f) & 0xf) << 4;
				*op0 |= ((uint16_t)(in[1] * 15.00f) & 0xf) << 8;
				*op0 |= ((uint16_t)(in[2] * 15.00f) & 0xf) << 12;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_X4R4G4B4_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op1 = (uint16_t*)out->pixel; *op1 = 0;
				*op1 |= ((uint16_t)(in[0] * 15.00f) & 0xf) << 4;
				*op1 |= ((uint16_t)(in[1] * 15.00f) & 0xf) << 8;
				*op1 |= ((uint16_t)(in[2] * 15.00f) & 0xf) << 12;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_A4B4G4R4_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[3] * 15.00f) & 0xf) << 0;
				*op0 |= ((uint16_t)(in[2] * 15.00f) & 0xf) << 4;
				*op0 |= ((uint16_t)(in[1] * 15.00f) & 0xf) << 8;
				*op0 |= ((uint16_t)(in[0] * 15.00f) & 0xf) << 12;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_X4B4G4R4_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op1 = (uint16_t*)out->pixel; *op1 = 0;
				*op1 |= ((uint16_t)(in[2] * 15.00f) & 0xf) << 4;
				*op1 |= ((uint16_t)(in[1] * 15.00f) & 0xf) << 8;
				*op1 |= ((uint16_t)(in[0] * 15.00f) & 0xf) << 12;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R5G6B5_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[0] * 31.00f) & 0x1f) << 0;
				*op0 |= ((uint16_t)(in[1] * 63.00f) & 0x3f) << 5;
				*op0 |= ((uint16_t)(in[2] * 31.00f) & 0x1f) << 11;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B5G6R5_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[2] * 31.00f) & 0x1f) << 0;
				*op0 |= ((uint16_t)(in[1] * 63.00f) & 0x3f) << 5;
				*op0 |= ((uint16_t)(in[0] * 31.00f) & 0x1f) << 11;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R5G5B5A1_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[0] * 31.00f) & 0x1f) << 0;
				*op0 |= ((uint16_t)(in[1] * 31.00f) & 0x1f) << 5;
				*op0 |= ((uint16_t)(in[2] * 31.00f) & 0x1f) << 10;
				*op0 |= ((uint16_t)(in[3] * 1.00f) & 0x1) << 15;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B5G5R5A1_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[2] * 31.00f) & 0x1f) << 0;
				*op0 |= ((uint16_t)(in[1] * 31.00f) & 0x1f) << 5;
				*op0 |= ((uint16_t)(in[0] * 31.00f) & 0x1f) << 10;
				*op0 |= ((uint16_t)(in[3] * 1.00f) & 0x1) << 15;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_A1B5G5R5_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[3] * 1.00f) & 0x1) << 0;
				*op0 |= ((uint16_t)(in[2] * 31.00f) & 0x1f) << 1;
				*op0 |= ((uint16_t)(in[1] * 31.00f) & 0x1f) << 6;
				*op0 |= ((uint16_t)(in[0] * 31.00f) & 0x1f) << 11;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_A1R5G5B5_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[3] * 1.00f) & 0x1) << 0;
				*op0 |= ((uint16_t)(in[0] * 31.00f) & 0x1f) << 1;
				*op0 |= ((uint16_t)(in[1] * 31.00f) & 0x1f) << 6;
				*op0 |= ((uint16_t)(in[2] * 31.00f) & 0x1f) << 11;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R5G5B5X1_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[0] * 31.00f) & 0x1f) << 0;
				*op0 |= ((uint16_t)(in[1] * 31.00f) & 0x1f) << 5;
				*op0 |= ((uint16_t)(in[2] * 31.00f) & 0x1f) << 10;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B5G5R5X1_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[2] * 31.00f) & 0x1f) << 0;
				*op0 |= ((uint16_t)(in[1] * 31.00f) & 0x1f) << 5;
				*op0 |= ((uint16_t)(in[0] * 31.00f) & 0x1f) << 10;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_X1R5G5B5_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op1 = (uint16_t*)out->pixel; *op1 = 0;
				*op1 |= ((uint16_t)(in[0] * 31.00f) & 0x1f) << 1;
				*op1 |= ((uint16_t)(in[1] * 31.00f) & 0x1f) << 6;
				*op1 |= ((uint16_t)(in[2] * 31.00f) & 0x1f) << 11;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_X1B5G5R5_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op1 = (uint16_t*)out->pixel; *op1 = 0;
				*op1 |= ((uint16_t)(in[2] * 31.00f) & 0x1f) << 1;
				*op1 |= ((uint16_t)(in[1] * 31.00f) & 0x1f) << 6;
				*op1 |= ((uint16_t)(in[0] * 31.00f) & 0x1f) << 11;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B2G3R3A8_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[2] * 3.00f) & 0x3) << 0;
				*op0 |= ((uint16_t)(in[1] * 7.00f) & 0x7) << 2;
				*op0 |= ((uint16_t)(in[0] * 7.00f) & 0x7) << 5;
				*op0 |= ((uint16_t)(in[3] * 255.00f) & 0xff) << 8;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8G8_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[0] * 255.00f) & 0xff) << 0;
				*op0 |= ((uint16_t)(in[1] * 255.00f) & 0xff) << 8;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8G8_SNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint16_t)(((in[0] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 0;
				*op0 |= (((uint16_t)(((in[1] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 8;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_G8R8_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[1] * 255.00f) & 0xff) << 0;
				*op0 |= ((uint16_t)(in[0] * 255.00f) & 0xff) << 8;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_G8R8_SNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint16_t)(((in[1] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 0;
				*op0 |= (((uint16_t)(((in[0] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 8;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8G8_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint16_t)in[0]) & 0xff) << 0;
				*op0 |= (((uint16_t)in[1]) & 0xff) << 8;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8G8_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint16_t)(in[0] + 128.00f)) & 0xff) << 0;
				*op0 |= (((uint16_t)(in[1] + 128.00f)) & 0xff) << 8;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8G8_SRGB:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)TinyImageFormat_Float2SRGB((float)in[0])) << 0;
				*op0 |= ((uint16_t)TinyImageFormat_Float2SRGB((float)in[1])) << 8;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[0] * 65535.00f) & 0xffff) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16_SNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint16_t)(((in[0] + 1.0f) * 0.5f) * 65535.00f)) & 0xffff) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint16_t)in[0]) & 0xffff) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint16_t)(in[0] + 32768.00f)) & 0xffff) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16_SFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16_SBFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)TinyImageFormat_FloatToBFloatAsUint((float)in[0])) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8G8B8_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint8_t)(in[0] * 255.00f) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op1 = (uint8_t*)out->pixel; *op1 = 0;
				*op1 |= ((uint8_t)(in[1] * 255.00f) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op2 = (uint8_t*)out->pixel; *op2 = 0;
				*op2 |= ((uint8_t)(in[2] * 255.00f) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8G8B8_SNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint8_t)(((in[0] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op1 = (uint8_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint8_t)(((in[1] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op2 = (uint8_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint8_t)(((in[2] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8G8B8_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint8_t)in[0]) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op1 = (uint8_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint8_t)in[1]) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op2 = (uint8_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint8_t)in[2]) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8G8B8_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint8_t)(in[0] + 128.00f)) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op1 = (uint8_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint8_t)(in[1] + 128.00f)) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op2 = (uint8_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint8_t)(in[2] + 128.00f)) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8G8B8_SRGB:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint8_t)TinyImageFormat_Float2SRGB((float)in[0])) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op1 = (uint8_t*)out->pixel; *op1 = 0;
				*op1 |= ((uint8_t)TinyImageFormat_Float2SRGB((float)in[1])) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op2 = (uint8_t*)out->pixel; *op2 = 0;
				*op2 |= ((uint8_t)TinyImageFormat_Float2SRGB((float)in[2])) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B8G8R8_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint8_t)(in[2] * 255.00f) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op1 = (uint8_t*)out->pixel; *op1 = 0;
				*op1 |= ((uint8_t)(in[1] * 255.00f) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op2 = (uint8_t*)out->pixel; *op2 = 0;
				*op2 |= ((uint8_t)(in[0] * 255.00f) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B8G8R8_SNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint8_t)(((in[2] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op1 = (uint8_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint8_t)(((in[1] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op2 = (uint8_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint8_t)(((in[0] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B8G8R8_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint8_t)in[2]) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op1 = (uint8_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint8_t)in[1]) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op2 = (uint8_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint8_t)in[0]) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B8G8R8_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint8_t)(in[2] + 128.00f)) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op1 = (uint8_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint8_t)(in[1] + 128.00f)) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op2 = (uint8_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint8_t)(in[0] + 128.00f)) & 0xff) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B8G8R8_SRGB:
			for(uint32_t w = 0; w < width; ++w) {
				uint8_t* op0 = (uint8_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint8_t)TinyImageFormat_Float2SRGB((float)in[2])) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op1 = (uint8_t*)out->pixel; *op1 = 0;
				*op1 |= ((uint8_t)TinyImageFormat_Float2SRGB((float)in[1])) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				uint8_t* op2 = (uint8_t*)out->pixel; *op2 = 0;
				*op2 |= ((uint8_t)TinyImageFormat_Float2SRGB((float)in[0])) << 0;
				out->pixel = (void*)(((uint8_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8G8B8A8_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint32_t)(in[0] * 255.00f) & 0xff) << 0;
				*op0 |= ((uint32_t)(in[1] * 255.00f) & 0xff) << 8;
				*op0 |= ((uint32_t)(in[2] * 255.00f) & 0xff) << 16;
				*op0 |= ((uint32_t)(in[3] * 255.00f) & 0xff) << 24;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8G8B8A8_SNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)(((in[0] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 0;
				*op0 |= (((uint32_t)(((in[1] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 8;
				*op0 |= (((uint32_t)(((in[2] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 16;
				*op0 |= (((uint32_t)(((in[3] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 24;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8G8B8A8_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)in[0]) & 0xff) << 0;
				*op0 |= (((uint32_t)in[1]) & 0xff) << 8;
				*op0 |= (((uint32_t)in[2]) & 0xff) << 16;
				*op0 |= (((uint32_t)in[3]) & 0xff) << 24;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8G8B8A8_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)(in[0] + 128.00f)) & 0xff) << 0;
				*op0 |= (((uint32_t)(in[1] + 128.00f)) & 0xff) << 8;
				*op0 |= (((uint32_t)(in[2] + 128.00f)) & 0xff) << 16;
				*op0 |= (((uint32_t)(in[3] + 128.00f)) & 0xff) << 24;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8G8B8A8_SRGB:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint32_t)TinyImageFormat_Float2SRGB((float)in[0])) << 0;
				*op0 |= ((uint32_t)TinyImageFormat_Float2SRGB((float)in[1])) << 8;
				*op0 |= ((uint32_t)TinyImageFormat_Float2SRGB((float)in[2])) << 16;
				*op0 |= ((uint32_t)(in[3] * 255.00f) & 0xff) << 24;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B8G8R8A8_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint32_t)(in[2] * 255.00f) & 0xff) << 0;
				*op0 |= ((uint32_t)(in[1] * 255.00f) & 0xff) << 8;
				*op0 |= ((uint32_t)(in[0] * 255.00f) & 0xff) << 16;
				*op0 |= ((uint32_t)(in[3] * 255.00f) & 0xff) << 24;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B8G8R8A8_SNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)(((in[2] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 0;
				*op0 |= (((uint32_t)(((in[1] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 8;
				*op0 |= (((uint32_t)(((in[0] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 16;
				*op0 |= (((uint32_t)(((in[3] + 1.0f) * 0.5f) * 255.00f)) & 0xff) << 24;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B8G8R8A8_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)in[2]) & 0xff) << 0;
				*op0 |= (((uint32_t)in[1]) & 0xff) << 8;
				*op0 |= (((uint32_t)in[0]) & 0xff) << 16;
				*op0 |= (((uint32_t)in[3]) & 0xff) << 24;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B8G8R8A8_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)(in[2] + 128.00f)) & 0xff) << 0;
				*op0 |= (((uint32_t)(in[1] + 128.00f)) & 0xff) << 8;
				*op0 |= (((uint32_t)(in[0] + 128.00f)) & 0xff) << 16;
				*op0 |= (((uint32_t)(in[3] + 128.00f)) & 0xff) << 24;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B8G8R8A8_SRGB:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint32_t)TinyImageFormat_Float2SRGB((float)in[2])) << 0;
				*op0 |= ((uint32_t)TinyImageFormat_Float2SRGB((float)in[1])) << 8;
				*op0 |= ((uint32_t)TinyImageFormat_Float2SRGB((float)in[0])) << 16;
				*op0 |= ((uint32_t)(in[3] * 255.00f) & 0xff) << 24;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R8G8B8X8_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint32_t)(in[0] * 255.00f) & 0xff) << 0;
				*op0 |= ((uint32_t)(in[1] * 255.00f) & 0xff) << 8;
				*op0 |= ((uint32_t)(in[2] * 255.00f) & 0xff) << 16;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B8G8R8X8_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint32_t)(in[2] * 255.00f) & 0xff) << 0;
				*op0 |= ((uint32_t)(in[1] * 255.00f) & 0xff) << 8;
				*op0 |= ((uint32_t)(in[0] * 255.00f) & 0xff) << 16;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint32_t)(in[0] * 65535.00f) & 0xffff) << 0;
				*op0 |= ((uint32_t)(in[1] * 65535.00f) & 0xffff) << 16;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_G16R16_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint32_t)(in[1] * 65535.00f) & 0xffff) << 0;
				*op0 |= ((uint32_t)(in[0] * 65535.00f) & 0xffff) << 16;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16_SNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)(((in[0] + 1.0f) * 0.5f) * 65535.00f)) & 0xffff) << 0;
				*op0 |= (((uint32_t)(((in[1] + 1.0f) * 0.5f) * 65535.00f)) & 0xffff) << 16;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_G16R16_SNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)(((in[1] + 1.0f) * 0.5f) * 65535.00f)) & 0xffff) << 0;
				*op0 |= (((uint32_t)(((in[0] + 1.0f) * 0.5f) * 65535.00f)) & 0xffff) << 16;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)in[0]) & 0xffff) << 0;
				*op0 |= (((uint32_t)in[1]) & 0xffff) << 16;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)(in[0] + 32768.00f)) & 0xffff) << 0;
				*op0 |= (((uint32_t)(in[1] + 32768.00f)) & 0xffff) << 16;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16_SFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16_SBFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint32_t)TinyImageFormat_FloatToBFloatAsUint((float)in[0])) << 0;
				*op0 |= ((uint32_t)TinyImageFormat_FloatToBFloatAsUint((float)in[1])) << 16;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R32_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)in[0]) & 0xffffffff) << 0;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R32_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)(in[0] + 2147483648.00f)) & 0xffffffff) << 0;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R32_SFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				float in0 = (float)in[0];
				*op0 |= ((uint32_t)*((uint32_t*)&in0)) << 0;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_A2R10G10B10_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint32_t)(in[3] * 3.00f) & 0x3) << 0;
				*op0 |= ((uint32_t)(in[0] * 1023.00f) & 0x3ff) << 2;
				*op0 |= ((uint32_t)(in[1] * 1023.00f) & 0x3ff) << 12;
				*op0 |= ((uint32_t)(in[2] * 1023.00f) & 0x3ff) << 22;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_A2R10G10B10_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)in[3]) & 0x3) << 0;
				*op0 |= (((uint32_t)in[0]) & 0x3ff) << 2;
				*op0 |= (((uint32_t)in[1]) & 0x3ff) << 12;
				*op0 |= (((uint32_t)in[2]) & 0x3ff) << 22;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_A2B10G10R10_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint32_t)(in[3] * 3.00f) & 0x3) << 0;
				*op0 |= ((uint32_t)(in[2] * 1023.00f) & 0x3ff) << 2;
				*op0 |= ((uint32_t)(in[1] * 1023.00f) & 0x3ff) << 12;
				*op0 |= ((uint32_t)(in[0] * 1023.00f) & 0x3ff) << 22;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_A2B10G10R10_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)in[3]) & 0x3) << 0;
				*op0 |= (((uint32_t)in[2]) & 0x3ff) << 2;
				*op0 |= (((uint32_t)in[1]) & 0x3ff) << 12;
				*op0 |= (((uint32_t)in[0]) & 0x3ff) << 22;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R10G10B10A2_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint32_t)(in[0] * 1023.00f) & 0x3ff) << 0;
				*op0 |= ((uint32_t)(in[1] * 1023.00f) & 0x3ff) << 10;
				*op0 |= ((uint32_t)(in[2] * 1023.00f) & 0x3ff) << 20;
				*op0 |= ((uint32_t)(in[3] * 3.00f) & 0x3) << 30;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B10G10R10A2_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint32_t)(in[2] * 1023.00f) & 0x3ff) << 0;
				*op0 |= ((uint32_t)(in[1] * 1023.00f) & 0x3ff) << 10;
				*op0 |= ((uint32_t)(in[0] * 1023.00f) & 0x3ff) << 20;
				*op0 |= ((uint32_t)(in[3] * 3.00f) & 0x3) << 30;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B10G10R10A2_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)in[2]) & 0x3ff) << 0;
				*op0 |= (((uint32_t)in[1]) & 0x3ff) << 10;
				*op0 |= (((uint32_t)in[0]) & 0x3ff) << 20;
				*op0 |= (((uint32_t)in[3]) & 0x3) << 30;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_B10G11R11_UFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16B16_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)(in[0] * 65535.00f) & 0xffff) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				uint16_t* op1 = (uint16_t*)out->pixel; *op1 = 0;
				*op1 |= ((uint16_t)(in[1] * 65535.00f) & 0xffff) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				uint16_t* op2 = (uint16_t*)out->pixel; *op2 = 0;
				*op2 |= ((uint16_t)(in[2] * 65535.00f) & 0xffff) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16B16_SNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint16_t)(((in[0] + 1.0f) * 0.5f) * 65535.00f)) & 0xffff) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				uint16_t* op1 = (uint16_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint16_t)(((in[1] + 1.0f) * 0.5f) * 65535.00f)) & 0xffff) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				uint16_t* op2 = (uint16_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint16_t)(((in[2] + 1.0f) * 0.5f) * 65535.00f)) & 0xffff) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16B16_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint16_t)in[0]) & 0xffff) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				uint16_t* op1 = (uint16_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint16_t)in[1]) & 0xffff) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				uint16_t* op2 = (uint16_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint16_t)in[2]) & 0xffff) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16B16_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint16_t)(in[0] + 32768.00f)) & 0xffff) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				uint16_t* op1 = (uint16_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint16_t)(in[1] + 32768.00f)) & 0xffff) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				uint16_t* op2 = (uint16_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint16_t)(in[2] + 32768.00f)) & 0xffff) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16B16_SFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				uint16_t* op1 = (uint16_t*)out->pixel; *op1 = 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				uint16_t* op2 = (uint16_t*)out->pixel; *op2 = 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16B16_SBFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint16_t* op0 = (uint16_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint16_t)TinyImageFormat_FloatToBFloatAsUint((float)in[0])) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				uint16_t* op1 = (uint16_t*)out->pixel; *op1 = 0;
				*op1 |= ((uint16_t)TinyImageFormat_FloatToBFloatAsUint((float)in[1])) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				uint16_t* op2 = (uint16_t*)out->pixel; *op2 = 0;
				*op2 |= ((uint16_t)TinyImageFormat_FloatToBFloatAsUint((float)in[2])) << 0;
				out->pixel = (void*)(((uint16_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16B16A16_UNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint64_t)(in[0] * 65535.00f) & 0xffff) << 0;
				*op0 |= ((uint64_t)(in[1] * 65535.00f) & 0xffff) << 16;
				*op0 |= ((uint64_t)(in[2] * 65535.00f) & 0xffff) << 32;
				*op0 |= ((uint64_t)(in[3] * 65535.00f) & 0xffff) << 48;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16B16A16_SNORM:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint64_t)(((in[0] + 1.0f) * 0.5f) * 65535.00f)) & 0xffff) << 0;
				*op0 |= (((uint64_t)(((in[1] + 1.0f) * 0.5f) * 65535.00f)) & 0xffff) << 16;
				*op0 |= (((uint64_t)(((in[2] + 1.0f) * 0.5f) * 65535.00f)) & 0xffff) << 32;
				*op0 |= (((uint64_t)(((in[3] + 1.0f) * 0.5f) * 65535.00f)) & 0xffff) << 48;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16B16A16_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint64_t)in[0]) & 0xffff) << 0;
				*op0 |= (((uint64_t)in[1]) & 0xffff) << 16;
				*op0 |= (((uint64_t)in[2]) & 0xffff) << 32;
				*op0 |= (((uint64_t)in[3]) & 0xffff) << 48;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16B16A16_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint64_t)(in[0] + 32768.00f)) & 0xffff) << 0;
				*op0 |= (((uint64_t)(in[1] + 32768.00f)) & 0xffff) << 16;
				*op0 |= (((uint64_t)(in[2] + 32768.00f)) & 0xffff) << 32;
				*op0 |= (((uint64_t)(in[3] + 32768.00f)) & 0xffff) << 48;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16B16A16_SFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R16G16B16A16_SBFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= ((uint64_t)TinyImageFormat_FloatToBFloatAsUint((float)in[0])) << 0;
				*op0 |= ((uint64_t)TinyImageFormat_FloatToBFloatAsUint((float)in[1])) << 16;
				*op0 |= ((uint64_t)TinyImageFormat_FloatToBFloatAsUint((float)in[2])) << 32;
				*op0 |= ((uint64_t)TinyImageFormat_FloatToBFloatAsUint((float)in[3])) << 48;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R32G32_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint64_t)in[0]) & 0xffffffff) << 0;
				*op0 |= (((uint64_t)in[1]) & 0xffffffff) << 32;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R32G32_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint64_t)(in[0] + 2147483648.00f)) & 0xffffffff) << 0;
				*op0 |= (((uint64_t)(in[1] + 2147483648.00f)) & 0xffffffff) << 32;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R32G32_SFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				float in0 = (float)in[0];
				*op0 |= ((uint64_t)*((uint32_t*)&in0)) << 0;
				float in1 = (float)in[1];
				*op0 |= ((uint64_t)*((uint32_t*)&in1)) << 32;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R32G32B32_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)in[0]) & 0xffffffff) << 0;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				uint32_t* op1 = (uint32_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint32_t)in[1]) & 0xffffffff) << 0;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				uint32_t* op2 = (uint32_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint32_t)in[2]) & 0xffffffff) << 0;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R32G32B32_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint32_t)(in[0] + 2147483648.00f)) & 0xffffffff) << 0;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				uint32_t* op1 = (uint32_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint32_t)(in[1] + 2147483648.00f)) & 0xffffffff) << 0;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				uint32_t* op2 = (uint32_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint32_t)(in[2] + 2147483648.00f)) & 0xffffffff) << 0;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R32G32B32_SFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint32_t* op0 = (uint32_t*)out->pixel; *op0 = 0;
				float in0 = (float)in[0];
				*op0 |= ((uint32_t)*((uint32_t*)&in0)) << 0;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				uint32_t* op1 = (uint32_t*)out->pixel; *op1 = 0;
				float in1 = (float)in[1];
				*op1 |= ((uint32_t)*((uint32_t*)&in1)) << 0;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				uint32_t* op2 = (uint32_t*)out->pixel; *op2 = 0;
				float in2 = (float)in[2];
				*op2 |= ((uint32_t)*((uint32_t*)&in2)) << 0;
				out->pixel = (void*)(((uint32_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R32G32B32A32_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint64_t)in[0]) & 0xffffffff) << 0;
				*op0 |= (((uint64_t)in[1]) & 0xffffffff) << 32;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op2 = (uint64_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint64_t)in[2]) & 0xffffffff) << 0;
				*op2 |= (((uint64_t)in[3]) & 0xffffffff) << 32;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R32G32B32A32_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint64_t)(in[0] + 2147483648.00f)) & 0xffffffff) << 0;
				*op0 |= (((uint64_t)(in[1] + 2147483648.00f)) & 0xffffffff) << 32;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op2 = (uint64_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint64_t)(in[2] + 2147483648.00f)) & 0xffffffff) << 0;
				*op2 |= (((uint64_t)(in[3] + 2147483648.00f)) & 0xffffffff) << 32;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R32G32B32A32_SFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				float in0 = (float)in[0];
				*op0 |= ((uint64_t)*((uint32_t*)&in0)) << 0;
				float in1 = (float)in[1];
				*op0 |= ((uint64_t)*((uint32_t*)&in1)) << 32;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op2 = (uint64_t*)out->pixel; *op2 = 0;
				float in2 = (float)in[2];
				*op2 |= ((uint64_t)*((uint32_t*)&in2)) << 0;
				float in3 = (float)in[3];
				*op2 |= ((uint64_t)*((uint32_t*)&in3)) << 32;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		default: return false;
	}
}

TIF_CONSTEXPR inline bool TinyImageFormat_CanPutLogicalPixelsD(TinyImageFormat const fmt) {
	switch(fmt) {
		case TinyImageFormat_R64_UINT: return true;
		case TinyImageFormat_R64_SINT: return true;
		case TinyImageFormat_R64_SFLOAT: return true;
		case TinyImageFormat_R64G64_UINT: return true;
		case TinyImageFormat_R64G64_SINT: return true;
		case TinyImageFormat_R64G64_SFLOAT: return true;
		case TinyImageFormat_R64G64B64_UINT: return true;
		case TinyImageFormat_R64G64B64_SINT: return true;
		case TinyImageFormat_R64G64B64_SFLOAT: return true;
		case TinyImageFormat_R64G64B64A64_UINT: return true;
		case TinyImageFormat_R64G64B64A64_SINT: return true;
		case TinyImageFormat_R64G64B64A64_SFLOAT: return true;
		default: return TinyImageFormat_CanPutLogicalPixelsF(fmt);
	}
}

TIF_CONSTEXPR inline bool TinyImageFormat_PutLogicalPixelsD(TinyImageFormat const fmt, double const *in, uint32_t const width, TinyImageFormat_PutOutput * out) {
	switch(fmt) {
		case TinyImageFormat_R64_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint64_t)in[0]) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R64_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint64_t)(in[0] + 9223372036854775808.00f)) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R64_SFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				double in0 = (double)in[0];
				*op0 |= ((uint64_t)*((uint64_t*)&in0)) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R64G64_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint64_t)in[0]) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op1 = (uint64_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint64_t)in[1]) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R64G64_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint64_t)(in[0] + 9223372036854775808.00f)) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op1 = (uint64_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint64_t)(in[1] + 9223372036854775808.00f)) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R64G64_SFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				double in0 = (double)in[0];
				*op0 |= ((uint64_t)*((uint64_t*)&in0)) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op1 = (uint64_t*)out->pixel; *op1 = 0;
				double in1 = (double)in[1];
				*op1 |= ((uint64_t)*((uint64_t*)&in1)) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R64G64B64_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint64_t)in[0]) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op1 = (uint64_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint64_t)in[1]) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op2 = (uint64_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint64_t)in[2]) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R64G64B64_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint64_t)(in[0] + 9223372036854775808.00f)) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op1 = (uint64_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint64_t)(in[1] + 9223372036854775808.00f)) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op2 = (uint64_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint64_t)(in[2] + 9223372036854775808.00f)) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R64G64B64_SFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				double in0 = (double)in[0];
				*op0 |= ((uint64_t)*((uint64_t*)&in0)) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op1 = (uint64_t*)out->pixel; *op1 = 0;
				double in1 = (double)in[1];
				*op1 |= ((uint64_t)*((uint64_t*)&in1)) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op2 = (uint64_t*)out->pixel; *op2 = 0;
				double in2 = (double)in[2];
				*op2 |= ((uint64_t)*((uint64_t*)&in2)) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R64G64B64A64_UINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint64_t)in[0]) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op1 = (uint64_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint64_t)in[1]) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op2 = (uint64_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint64_t)in[2]) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op3 = (uint64_t*)out->pixel; *op3 = 0;
				*op3 |= (((uint64_t)in[3]) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R64G64B64A64_SINT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				*op0 |= (((uint64_t)(in[0] + 9223372036854775808.00f)) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op1 = (uint64_t*)out->pixel; *op1 = 0;
				*op1 |= (((uint64_t)(in[1] + 9223372036854775808.00f)) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op2 = (uint64_t*)out->pixel; *op2 = 0;
				*op2 |= (((uint64_t)(in[2] + 9223372036854775808.00f)) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op3 = (uint64_t*)out->pixel; *op3 = 0;
				*op3 |= (((uint64_t)(in[3] + 9223372036854775808.00f)) & 0x0) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		case TinyImageFormat_R64G64B64A64_SFLOAT:
			for(uint32_t w = 0; w < width; ++w) {
				uint64_t* op0 = (uint64_t*)out->pixel; *op0 = 0;
				double in0 = (double)in[0];
				*op0 |= ((uint64_t)*((uint64_t*)&in0)) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op1 = (uint64_t*)out->pixel; *op1 = 0;
				double in1 = (double)in[1];
				*op1 |= ((uint64_t)*((uint64_t*)&in1)) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op2 = (uint64_t*)out->pixel; *op2 = 0;
				double in2 = (double)in[2];
				*op2 |= ((uint64_t)*((uint64_t*)&in2)) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				uint64_t* op3 = (uint64_t*)out->pixel; *op3 = 0;
				double in3 = (double)in[3];
				*op3 |= ((uint64_t)*((uint64_t*)&in3)) << 0;
				out->pixel = (void*)(((uint64_t*)out->pixel) + 1);
				in+=4;
			}
			return true;
		default:
		{
			bool ret = true;
			for(uint32_t w = 0; w < width && ret; ++w) {
				float inF[4] = {(float)in[0], (float)in[1], (float)in[2], (float)in[3]};
				ret = TinyImageFormat_PutLogicalPixelsF(fmt, inF, 1, out);
				in += 4;
			}
			return ret;
		}
	}
}

#undef TIF_CONSTEXPR

